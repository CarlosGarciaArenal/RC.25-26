%%***************************************************
\documentclass[a4paper,12pt]{article}

%% PACKAGES
\usepackage{amssymb}% to have some extra types of fonts
\usepackage{amsmath}
\usepackage{enumitem}
%% - writing in Spanish
\usepackage[latin1]{inputenc}% To type Spanish accents
\usepackage[spanish]{babel}% to have Spanish captions
%% - doc. formatting
\usepackage[a4paper,left=3.1cm,right=3.1cm,bottom=2.5cm,top=2.5cm]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

\fancyhead[L]{Universidad de Cantabria}    % L = Left
\fancyhead[C]{Grado en Matemáticas}       % C = Center
\fancyhead[R]{Grado en Ing. Informática}      % R = Right
\fancyfoot[R]{\thepage}

\title{Representación del conocimiento \\ Práctica 1}
\author{Víctor Castañeda Balmori, Mario Cuesta Rivavelarde, \\
Carlos García Arenal, Laro Ayesa Sánchez y Alexandru Solovei Popa}
\date{03/10/2025}

\begin{document}

\maketitle
\thispagestyle{fancy}
El objetivo de la práctica es programar el algoritmo que determina si dos nodos de un grafo son separables dado otro conjunto de nodos. Es decir, el algoritmo que determina si $X \perp _g Y \mid Z$. En este documento analizamos la complejidad del código implementado en el fichero \textit{practica1.py}. \\ \\
Para el desarrollo de la práctica hemos dividido el trabajo en el grupo en los 3 pasos del algoritmo. El análisis de la complejidad lo hemos hecho, por tanto, primero por separado cada función (o cada paso con sus funciones) y después en conjunto.

\section{Complejidad del paso 1}

\section{Complejidad del paso 2}
El paso 2 del algoritmo consiste en añadir aristas entre los nodos que tienen el mismo hijo y eliminar la direccionalidad de las aristas. Por lo tanto, el algoritmo que hemos desarrollado consiste en recorrer los nodos del grafo, recorriendo los padres de cada nodo, añadiendo aristas entre los padres con hijos en común. Todo esto, pasando el grafo dirigido a no dirigido. \\ \\
En el peor caso (algo muy poco frecuente) todos los nodos estarán unidos a los demás, de forma que tendrá cada nodo (n-1) padres. De esta forma, tendremos un bucle que recorre todos los nodos O(n). Dentro tendremos un bucle que recorre los padres O(n) y otro dentro de este que también depende de n (siendo n el número de nodos del grafo). En realidad, los dos bucles de los padres dependen de n, pero el de dentro empieza en i + 1 quedándonos una secuencia de iteraciones n + (n-1) + (n-2) + (n-3)... que da lugar a una complejidad $O(n^2/2)$. Sigue dependiendo de n pero es más eficiente. Por lo tanto, \textbf{en el peor caso la complejidad del algoritmo en de $O(n^3)$}. \\ \\ 
Sin embargo, lo normal en una red bayesiana no es esto, por lo que podríamos poner una cota de padres máximos que tenga cada hijo (p).La complejidad de los bucles interiores anidados en $O(p^2/2)$. La complejidad del algoritmo, por tanto, sería $O(n * p^2)$ siendo n el número de nodos y p el número máximo de padres de cada nodo.
 
\section{Complejidad del paso 3}





\end{document}
